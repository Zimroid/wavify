import './App.css';
import styles from './App.module.css';
import { ChangeEvent, SyntheticEvent, useRef, useState } from 'react';
import FullSizeGrid from './FullSizeGrid/FullSizeGrid';
import useTick from './useTick/useTick';
import WavifiedImage from './WavifiedImage/WavifiedImage';
import { box, color, imageWavified, WaveConfig } from './type';

export default function App() {
  /** The vertical size of the waves */
  const intensity = 50;

  /** The number of waves for the longest side of the image */
  const maxLength = 60;

  const delayTick = useRef(1);
  const tickCanStart = useRef(false);

  const defaultImageWavified: imageWavified = {
    id: 0,
    listWave: [],
    darkest: 0,
    brightest: 100
  };

  /** The list of wavified image to display */
  const [imageWavified, setImageWavified] = useState(defaultImageWavified);

  const defaultListImagesWavified: imageWavified[] = []

  /** The list of wavified image available to display */
  const [listImagesWavified, setListImagesWavified] = useState(defaultListImagesWavified);

  /** The index of the current image displayed from images */
  const [currentImageIndex, setCurrentImageIndex] = useState(0);

  /** To get a string of at least given size by puting zeros at the left */
  const fillStringWithZero = (originalText: string, nbCharInOutput: number) => {
    let res = originalText;
    while (res.length < nbCharInOutput) {
      res = `0${res}`;
    }
    return res;
  };

  /** To get a string usable as a css color */
  const colorObjectToHexa = (colorObject: color) => {
    return `#${fillStringWithZero(colorObject.r, 2)}${fillStringWithZero(colorObject.g, 2)}${fillStringWithZero(colorObject.b, 2)}${fillStringWithZero(colorObject.a, 2)}`
  }

  /** To get the avergage color and the greyscale of a pixel array */
  const computeAverageColorAndGreyLvlFromPixelsArray = (pixelsToCompute: Uint8ClampedArray[]) => {
    const pixelSommeByColorComposant = {r: 0, g: 0, b: 0, a: 0};
    pixelsToCompute.forEach(pixel => {
      pixelSommeByColorComposant.r += pixel[0];
      pixelSommeByColorComposant.g += pixel[1];
      pixelSommeByColorComposant.b += pixel[2];
      pixelSommeByColorComposant.a += pixel[3];
    });
    const averageColor = {
      r: Math.round(pixelSommeByColorComposant.r / pixelsToCompute.length),
      g: Math.round(pixelSommeByColorComposant.g / pixelsToCompute.length),
      b: Math.round(pixelSommeByColorComposant.b / pixelsToCompute.length),
      a: Math.round(pixelSommeByColorComposant.a / pixelsToCompute.length),
    }
    const avergageColorInHexa = {
      r: averageColor.r.toString(16),
      g: averageColor.g.toString(16),
      b: averageColor.b.toString(16),
      a: averageColor.a.toString(16),
    }

    return {
      color: colorObjectToHexa(avergageColorInHexa),
      grey: (averageColor.r + averageColor.g + averageColor.b) / 3,
    };
  }

  /** Reduce a two dimensional pixel array from a given canvas to a single dimension array */
  const partImageToArray = (boundaries: box, canvas: HTMLCanvasElement) => {
    const pixelsToCompute = [];
    for (let i = boundaries.left; i < boundaries.right; i++) {
      for (let j = boundaries.top; j < boundaries.bottom; j++) {
        const tmp = canvas.getContext('2d')
        if (tmp) {
          const originalPixel = tmp.getImageData(i, j, 1, 1).data;
          pixelsToCompute.push(originalPixel);
        }
      }
    }

    return pixelsToCompute;
  }

  /** To get the avergage color and the greyscale of a given canvas part */
  const computeColorAndGreyLvlForPartImage = (boundaries: box, canvas: HTMLCanvasElement) => {
    const pixelsToCompute = partImageToArray(boundaries, canvas);
    return computeAverageColorAndGreyLvlFromPixelsArray(pixelsToCompute);
  }

  /** To get the boundary coordinates */
  const comuteSubImageBoundaries = (top: number, left: number, height: number, width: number): box => {
    return {
      left: Math.round(left),
      right: Math.round(left + width - 1),
      top: Math.round(top),
      bottom: Math.round(top + height - 1),
    }
  }

  /** To get a the config of all waves generated by the given canvas */
  const getListWaveConfigFromCanvas = (gridWidth: number, gridHeight: number, canvas: HTMLCanvasElement): imageWavified => {
    const listWaveConfig: WaveConfig[] = [];
    
    const canvasSubPartWidth = canvas.width / gridWidth;
    const canvasSubPartHeight = canvas.height / gridHeight;
    
    let darkest = 255;
    let brightest = 0;

    for(let i = 0; i < gridWidth; i++) {
      for (let j = 0; j < gridHeight; j++) {
        const boundaries = comuteSubImageBoundaries(canvasSubPartHeight * j, canvasSubPartWidth * i, canvasSubPartHeight, canvasSubPartWidth)
        const {color, grey} = computeColorAndGreyLvlForPartImage(boundaries, canvas);
  
        listWaveConfig.push({
          x: i,
          y: j,
          color: color,
          grey: grey,
        });

        if (darkest > grey) {
          darkest = grey;
        }
        if (brightest < grey) {
          brightest = grey;
        }
      }
    }

    return { id: Date.now(), listWave: listWaveConfig, darkest, brightest };
  }

  /** Create an hidden canvas and display the given image */
  const createHiddenCanvasFromImage = (image: HTMLImageElement): HTMLCanvasElement => {
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;

    const tmp = canvas.getContext('2d');
    if (tmp) {
      tmp.drawImage(image, 0, 0, image.width, image.height);
    }

    return canvas;
  }

  /** To get the grid size based on the image proportion and the max grid size */
  const computeGridSizeFromImage = ({width, height}: {width: number, height: number}) => {
    let gridWidth = 0;
    let gridHeight = 0; 

    if (width > height) {
      const coef = width / maxLength;
      gridWidth = maxLength;
      gridHeight = Math.round(height / coef);
    } else {
      const coef = height / maxLength;
      gridWidth = Math.round(width / coef);
      gridHeight = maxLength;
    }

    return { gridWidth, gridHeight };
  }

  /** To get a list of wave component to display in grif from a given image */
  const getListWaveFromImage = (image: HTMLImageElement) => {
    const canvas = createHiddenCanvasFromImage(image);
    const { gridWidth, gridHeight } = computeGridSizeFromImage(image)

    const imgWavified = getListWaveConfigFromCanvas(gridWidth, gridHeight, canvas);
    canvas.remove();

    return imgWavified;
  }

  /** To display the given wavified image */
  const displayWavifiedImage = (imgWavified: imageWavified) => {
    setImageWavified(imgWavified);
  }

  /** To display the given wavified image if nothing it currently displayed */
  const displayWavifiedImageIfNothingIsCurrentlyDisplayed = () => {
    if (imageWavified.id === 0 && listImagesWavified.length > 0 && !tickCanStart.current) {
      displayWavifiedImage(listImagesWavified[0]);
      tickCanStart.current = true;
    }
  }

  /** To add the given wavified image to the images list */
  const addWavifiedImageToImagesList = (imgWavified: imageWavified) => {
    const newImages = [...listImagesWavified];
    newImages.push(imgWavified);
    setListImagesWavified(newImages);
  }

  /** To handle a new image loaded */
  const imgLoaded = (image: HTMLImageElement) => {
    const imgWavified = getListWaveFromImage(image);
    addWavifiedImageToImagesList(imgWavified);
    displayWavifiedImageIfNothingIsCurrentlyDisplayed();
  }

  /** To handle an image from an input file */
  const handleImageLoadFromInput = (event: ChangeEvent<HTMLInputElement>) => {
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        const tmp = e.target;
        if (tmp) {
          img.src = `${tmp.result}`;
        }
        img.onload = () => { imgLoaded(img) };
    }
    const tmp = event.target.files;
    if (tmp) {
      reader.readAsDataURL(tmp[0]);
    }
  }

  /** To handle an image from an img html balise */
  const handleImageLoadFromImgBalise = (image: SyntheticEvent<HTMLImageElement, Event>) => {
    imgLoaded(image.target as HTMLImageElement);
  }

  /** To display the next image in the images list */
  const displayNextImage = () => {
    if (listImagesWavified.length > 1) {
      const newImageIndex = (currentImageIndex + 1) % listImagesWavified.length;
      if (listImagesWavified[currentImageIndex].id !== listImagesWavified[newImageIndex].id) {
        setCurrentImageIndex(newImageIndex);
        displayWavifiedImage(listImagesWavified[newImageIndex]);
      } else {
        setCurrentImageIndex(newImageIndex);
        displayNextImage();
      }
    }
  }

  /** To display a new image every 10 seconds */
  useTick(() => {
    if (tickCanStart) {
      if (delayTick.current === 0) {
        displayNextImage();
      }
      else {
        delayTick.current = delayTick.current - 1;
      }
    }
  }, 10000);

  return (
    <div className={styles.demoFullSize}>
      <img src="image.jpg" onLoad={handleImageLoadFromImgBalise} className={styles.hideImgTest} alt="test"></img>
      <img src="link.jpg" onLoad={handleImageLoadFromImgBalise} className={styles.hideImgTest} alt="test"></img>
      <FullSizeGrid>
        <WavifiedImage imageConfig={imageWavified} intensity={intensity}></WavifiedImage>
      </FullSizeGrid>
      <input type="file" id="imageLoader" name="imageLoader" className={styles.inputTest} onChange={handleImageLoadFromInput}/>
    </div>
  );
}