{"version":3,"sources":["App.module.css","SquareCell/SquareCell.module.css","SquareGrid/SquareGrid.module.css","Wave/Wave.module.css","useTick/useTick.tsx","Wave/type.ts","SquareCell/SquareCell.tsx","Wave/Wave.tsx","WavifiedImage/WavifiedImage.tsx","WavifiedImage/WavifyUtils.ts","SquareGrid/SquareGrid.tsx","App.tsx","useScreenSize/useScreenSize.tsx","reportWebVitals.js","index.js"],"names":["module","exports","useTick","func","time","savedFunction","useRef","useEffect","current","interval","setInterval","clearInterval","WavePhase","SquareCell","x","y","children","className","styles","cellWrapper","style","cell","Wave","waveConfig","useState","color","displayedColor","setDisplayedColor","nbPeriodSaved","nbPeriod","phase","DISPLAYED","computePath","nbPeriodForPath","intensityForPath","res","i","point","previousPoint","halfway","intensityValue","low","hight","intensity","path","setPath","goToWhiteLine","useCallback","goToNewPath","prepareNewPath","WHITE_LINE","xmlns","viewBox","strokeWidth","fill","vectorEffect","strokeLinecap","WavifiedImage","imageConfig","width","height","progress","setProgress","imagePhase","image","setImage","firstDisplay","biggestSide","listWave","map","elt","index","position","WHITE_LINE_PREPARATION","Math","round","prevImage","grey","darkest","brightest","fillStringWithZero","originalText","nbCharInOutput","length","computeColorAndGreyLvlForPartImage","boundaries","canvas","pixelsToCompute","pixelSommeByColorComposant","r","g","b","a","forEach","pixel","colorObject","averageColor","avergageColorInHexa","toString","computeAverageColorAndGreyLvlFromPixelsArray","left","right","j","top","bottom","tmp","getContext","originalPixel","getImageData","data","push","partImageToArray","getListWaveFromImage","document","createElement","canvasComputedWidth","canvasComputedHeight","maxSize","ratio","drawImage","createHiddenCanvasFromImage","outputImageWidth","outputImageHeight","originalImageWidth","originalImageHeight","drawedImageWidth","drawedImageHeight","coef","trunc","computeDrawedGridSizeFromImage","imgWavified","gridWidth","gridHeight","listWaveConfig","canvasSubPartWidth","canvasSubPartHeight","borderTopHeight","borderLeftWidth","listWaveConfigSorted","sort","id","Date","now","getListWaveConfigFromCanvas","remove","SquareGrid","nbColumns","nbRows","gridContainer","grid","App","delayTick","tickCanStart","imageWavified","setImageWavified","listImagesWavified","setListImagesWavified","currentImageIndex","setCurrentImageIndex","window","innerWidth","innerHeight","screenSize","setScreenSize","handleResize","addEventListener","removeEventListener","useScreenSize","widthScreen","heightScreen","setGrid","displayWavifiedImage","imgLoaded","newImages","addWavifiedImageToImagesList","handleImageLoadFromImgBalise","target","displayNextImage","newImageIndex","demoFullSize","src","onLoad","hideImgTest","alt","type","name","inputTest","onChange","event","reader","FileReader","onload","e","img","Image","result","files","readAsDataURL","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"oFACAA,EAAOC,QAAU,CAAC,aAAe,0BAA0B,YAAc,yBAAyB,UAAY,yB,mBCA9GD,EAAOC,QAAU,CAAC,YAAc,gCAAgC,KAAO,2B,gBCAvED,EAAOC,QAAU,CAAC,cAAgB,kCAAkC,KAAO,2B,iBCA3ED,EAAOC,QAAU,CAAC,KAAO,qB,iKCCV,SAASC,EAAQC,EAAkBC,GAChD,IAAMC,EAAgBC,kBAAO,eAU7B,OATAC,qBAAU,WACRF,EAAcG,QAAUL,KAG1BI,qBAAU,WACR,IAAME,EAAWC,aAAY,WAAQL,EAAcG,YAAcJ,GACjE,OAAO,kBAAMO,cAAcF,MAC1B,CAACL,IAEG,K,ICNGQ,E,uBCEG,SAASC,EAAT,GAA8C,IAAzBC,EAAwB,EAAxBA,EAAGC,EAAqB,EAArBA,EAAGC,EAAkB,EAAlBA,SACtC,OACI,qBAAKC,UAAWC,IAAOC,YAAaC,MAAO,CAAC,MAAON,EAAG,MAAOC,GAA7D,SACI,qBAAKE,UAAWC,IAAOG,KAAvB,SACKL,O,SDNLJ,O,yBAAAA,I,2BAAAA,I,oDAAAA,M,0BECG,SAASU,EAAT,GAAoC,IAArBC,EAAoB,EAApBA,WAAoB,EAEFC,mBAASD,EAAWE,OAFlB,mBAEvCC,EAFuC,KAEvBC,EAFuB,KAKxCC,EAAgBtB,iBAAOiB,EAAWM,UAElCC,EAAQxB,iBAAOM,EAAUmB,WAGzBC,EAAc,SAACC,EAAyBC,GAE1C,IADA,IAAIC,EAAM,SACDC,EAAI,EAAGA,GAAKH,EAAiBG,IAAK,CACvC,IAAMC,EAAS,IAAMJ,EAAmBG,EAClCE,EAAiB,IAAML,GAAoBG,EAAI,GAC/CG,GAAYF,EAAQC,GAAiB,EAAKA,EAE1CE,EAAkBN,EAAmB,IAAO,IAC5CO,EAAM,GAAKD,EACXE,EAAQ,GAAKF,EACnBL,GAAG,aAAUI,EAAV,YAAqBE,EAArB,YAA4BF,EAA5B,YAAuCG,EAAvC,YAAgDL,EAAhD,OAEP,OAAOF,GAtBmC,EA0BtBX,mBAASQ,EAAYT,EAAWM,SAAUN,EAAWoB,YA1B/B,mBA0BvCC,EA1BuC,KA0BjCC,EA1BiC,KA6BxCC,EAAgBC,uBAAY,WAC9BF,EAAQb,EAAYJ,EAAcpB,QAAS,IAC3CmB,EAAkB,aACnB,IAGGqB,EAAcD,uBAAY,WAC5BF,EAAQb,EAAYT,EAAWM,SAAUN,EAAWoB,YACpDhB,EAAkBJ,EAAWE,SAC9B,CAACF,EAAWM,SAAUN,EAAWoB,UAAWpB,EAAWE,QAEpDwB,EAAiBF,uBAAY,WAC/BF,EAAQb,EAAYT,EAAWM,SAAU,IACzCD,EAAcpB,QAAUe,EAAWM,SACnCF,EAAkB,aACnB,CAACJ,EAAWM,WAmBf,OAjBAtB,qBAAU,WACN,GAAIuB,EAAMtB,UAAYe,EAAWO,MAE7B,OADAA,EAAMtB,QAAUe,EAAWO,MACnBA,EAAMtB,SACV,KAAKI,EAAUsC,WACXJ,IACA,MACJ,KAAKlC,EAAUmB,UACXiB,IACA,MACJ,QACIC,OAIb,CAAC1B,EAAWO,MAAOgB,EAAeE,EAAaC,IAG9C,qBAAKhC,UAAWC,IAAOG,KAAvB,SACI,qBAAK8B,MAAM,6BAA6BC,QAAO,gBAA/C,SACI,sBAAMhC,MAAO,CAAC,SAAS,IAAT,OAAcwB,EAAd,KAAuB,UAAWlB,GAAiB2B,YAAY,IAAIC,KAAK,OAAOC,aAAa,qBAAqBC,cAAc,cC5D9I,SAASC,EAAT,GAAwE,IAAhDC,EAA+C,EAA/CA,YAAaf,EAAkC,EAAlCA,UAAWgB,EAAuB,EAAvBA,MAAOC,EAAgB,EAAhBA,OAAgB,EAClDpC,oBAAU,IADwC,mBAC3EqC,EAD2E,KACjEC,EADiE,KAE5EC,EAA4CzD,iBAAO,IAFyB,EAIxDkB,mBAASkC,GAJ+C,mBAI3EM,EAJ2E,KAIpEC,EAJoE,KAK5EC,EAAe5D,iBAAO,GAEtB6D,EAAcR,EAAQC,EAASD,EAAQC,EA2C7C,OAzCA1D,GAAQ,WACA2D,GAAY,KAAOK,EAAa1D,QAAU,IAC1CuD,EAAWvD,QAAUwD,EAAMI,SAASC,KAAI,SAACC,EAAKC,GAC1C,IAAMC,EAAYF,EAAIxD,EAAI6C,EAAQ,IAClC,GAAIW,EAAIvD,EAAI,IAAM,EAAG,CACjB,GAAIyD,GAAYX,EACZ,OAAOjD,EAAUmB,UACd,GAAIyC,GAAYX,EAAW,EAC9B,OAAOjD,EAAU6D,uBACd,GAAID,GAAYX,EAAW,GAC9B,OAAOjD,EAAUsC,eAElB,CACH,GAAIsB,GAAY,IAAMX,EAClB,OAAOjD,EAAUmB,UACd,GAAIyC,GAAY,KAAOX,EAAW,GACrC,OAAOjD,EAAU6D,uBACd,GAAID,GAAY,KAAOX,EAAW,IACrC,OAAOjD,EAAUsC,WAIzB,OAAOa,EAAWvD,QAAQ+D,MAE9BT,EAAYD,EAAWa,KAAKC,MAAMR,EAAcR,OAErD,IAEHpD,qBAAU,WACN0D,GAAS,SAAAW,GAAS,OAAKA,OACxB,CAACf,IAEJtD,qBAAU,WACNuD,GAAa,IACbG,EAASP,GACLQ,EAAa1D,QAAU,IACvB0D,EAAa1D,QAAU0D,EAAa1D,QAAU,EAC9CuD,EAAWvD,QAAUkD,EAAYU,SAASC,KAAI,kBAAMzD,EAAUmB,gBAEnE,CAAC2B,IAEG,mCACHM,EAAMI,SAASC,KAAI,SAAC9C,EAAYgD,GAC5B,IAAM1C,EAAW6C,KAAKC,OAAOpD,EAAWsD,KAAOnB,EAAYoB,UAAYpB,EAAYqB,UAAYrB,EAAYoB,SAAW,GAEtH,OAAO,cAACjE,EAAD,CAAYC,EAAGS,EAAWT,EAAGC,EAAGQ,EAAWR,EAA3C,SACH,cAACO,EAAD,CAAMC,WAAY,CACdM,SAAuB,IAAbA,EAAiB,EAAIA,EAC/Bc,UAAwB,IAAbd,EAAiB,EAAIc,EAChClB,MAAOF,EAAWE,MAClBK,MAAOiC,EAAWvD,QAAQ+D,KACtB,OAAOA,IANuC,SAASA,QCjExE,SAASS,EAAmBC,EAAsBC,GAEvD,IADA,IAAI/C,EAAM8C,EACH9C,EAAIgD,OAASD,GAClB/C,EAAG,WAAOA,GAEZ,OAAOA,EAqDF,SAASiD,EAAmCC,EAAiBC,GAElE,OA9CK,SAAsDC,GAC3D,IAAMC,EAA6B,CAACC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GACzDL,EAAgBM,SAAQ,SAAAC,GACtBN,EAA2BC,GAAKK,EAAM,GACtCN,EAA2BE,GAAKI,EAAM,GACtCN,EAA2BG,GAAKG,EAAM,GACtCN,EAA2BI,GAAKE,EAAM,MAExC,IAbgCC,EAa1BC,EAAe,CACnBP,EAAGf,KAAKC,MAAMa,EAA2BC,EAAIF,EAAgBJ,QAC7DO,EAAGhB,KAAKC,MAAMa,EAA2BE,EAAIH,EAAgBJ,QAC7DQ,EAAGjB,KAAKC,MAAMa,EAA2BG,EAAIJ,EAAgBJ,QAC7DS,EAAGlB,KAAKC,MAAMa,EAA2BI,EAAIL,EAAgBJ,SAEzDc,EAAsB,CAC1BR,EAAGO,EAAaP,EAAES,SAAS,IAC3BR,EAAGM,EAAaN,EAAEQ,SAAS,IAC3BP,EAAGK,EAAaL,EAAEO,SAAS,IAC3BN,EAAGI,EAAaJ,EAAEM,SAAS,KAG7B,MAAO,CACLzE,OA3B8BsE,EA2BLE,EA1BrB,IAAN,OAAWjB,EAAmBe,EAAYN,EAAG,IAA7C,OAAkDT,EAAmBe,EAAYL,EAAG,IAApF,OAAyFV,EAAmBe,EAAYJ,EAAG,IAA3H,OAAgIX,EAAmBe,EAAYH,EAAG,KA2BhKf,MAAOmB,EAAaP,EAAIO,EAAaN,EAAIM,EAAaL,GAAK,GAuBtDQ,CAlBF,SAA0Bd,EAAiBC,GAEhD,IADA,IAAMC,EAAkB,GACfnD,EAAIiD,EAAWe,KAAMhE,EAAIiD,EAAWgB,MAAOjE,IAClD,IAAK,IAAIkE,EAAIjB,EAAWkB,IAAKD,EAAIjB,EAAWmB,OAAQF,IAAK,CACvD,IAAMG,EAAMnB,EAAOoB,WAAW,MAC9B,GAAID,EAAK,CACP,IAAME,EAAgBF,EAAIG,aAAaxE,EAAGkE,EAAG,EAAG,GAAGO,KACnDtB,EAAgBuB,KAAKH,IAK3B,OAAOpB,EAKiBwB,CAAiB1B,EAAYC,IAiKhD,SAAS0B,EAAqBhD,EAAyBL,EAAeC,GAC3E,IAAM0B,EA3DD,SAAqCtB,GAC1C,IAAMsB,EAAS2B,SAASC,cAAc,UAElCC,EAAsBnD,EAAML,MAC5ByD,EAAuBpD,EAAMJ,OAC3ByD,EAAU,IAEhB,GAAIF,EAAsBE,GAAWD,EAAuBC,EAAS,CACnE,IAAMC,EAAQH,EAAsBC,EAChCD,EAAsBC,GACxBD,EAAsBE,EACtBD,EAAuBC,EAAUC,IAEjCH,EAAsBE,EAAUC,EAChCF,EAAuBC,GAI3B/B,EAAO3B,MAAQwD,EACf7B,EAAO1B,OAASwD,EAEhB,IAAMX,EAAMnB,EAAOoB,WAAW,MAK9B,OAJID,GACFA,EAAIc,UAAUvD,EAAO,EAAG,EAAGA,EAAML,MAAOK,EAAMJ,OAAQ,EAAG,EAAG0B,EAAO3B,MAAO2B,EAAO1B,QAG5E0B,EAiCQkC,CAA4BxD,GAD+D,EA5BrG,WAAmIyD,EAA0BC,GAAqF,IAAlMC,EAAiM,EAAxMhE,MAAmCiE,EAAqK,EAA7KhE,OACrEiE,EAAmB,EACnBC,EAAoB,EAExB,GAAIH,EAAqBC,EAAqB,CAC5C,IAAMG,EAAOJ,EAAqBF,EAClCI,EAAmBJ,GACnBK,EAAoBpD,KAAKsD,MAAMJ,EAAsBG,IAE7BL,IACtBG,EAAmBnD,KAAKsD,MAAML,EAAqBI,GACnDD,EAAoBJ,OAEjB,CACL,IAAMK,EAAOH,EAAsBF,EAEnCI,EAAoBJ,GADpBG,EAAmBnD,KAAKsD,MAAML,EAAqBI,IAG5BN,IACrBI,EAAmBJ,EACnBK,EAAoBpD,KAAKsD,MAAMJ,EAAsBG,IAIzD,MAAO,CAAEF,mBAAkBC,qBAMqBG,CAA+BjE,EAAOL,EAAOC,GAEvFsE,EAtJD,SAAqCL,EAA0BC,EAA2BxC,EAA2B6C,EAAmBC,GAY7I,IAXA,IAXwC7B,EAAaH,EAAcxC,EAAgBD,EAW7E0E,EAA+B,GAE/BC,EAAqBhD,EAAO3B,MAAQkE,EACpCU,EAAsBjD,EAAO1B,OAASkE,EAExChD,EAAU,IACVC,EAAY,EAEVyD,EAAkB9D,KAAKsD,OAAOI,EAAaN,GAAqB,GAChEW,EAAkB/D,KAAKsD,OAAOG,EAAYN,GAAoB,GAE5DzF,EAAI,EAAGA,EAAIyF,EAAkBzF,IACnC,IAAK,IAAIkE,EAAI,EAAGA,EAAIwB,EAAmBxB,IAAK,CAC1C,IAD0C,EAEpBlB,GAzBcmB,EAwBSgC,EAAsBjC,EAxBlBF,EAwBqBkC,EAAqBlG,EAxB5BwB,EAwB+B2E,EAxBf5E,EAwBoC2E,EAvBhH,CACLlC,KAAM1B,KAAKC,MAAMyB,GACjBC,MAAO3B,KAAKC,MAAMyB,EAAOzC,EAAQ,GACjC4C,IAAK7B,KAAKC,MAAM4B,GAChBC,OAAQ9B,KAAKC,MAAM4B,EAAM3C,EAAS,KAoBqC0B,GAA9D7D,EAFmC,EAEnCA,MAAOoD,EAF4B,EAE5BA,KAEdwD,EAAevB,KAAK,CAClBhG,EAAGsB,EAAIqG,EACP1H,EAAGuF,EAAIkC,EACP/G,MAAOA,EACPoD,KAAMA,IAGJC,EAAUD,IACZC,EAAUD,GAERE,EAAYF,IACdE,EAAYF,GAKlB,IAAK,IAAIzC,EAAI,EAAGA,EAAI+F,EAAW/F,IAC7B,IAAK,IAAIkE,EAAI,EAAGA,EAAIkC,EAAiBlC,IACnC+B,EAAevB,KAAK,CAClBhG,EAAGsB,EACHrB,EAAGuF,EACH7E,MAAO,UACPoD,KAAMC,IAKZ,IAAK,IAAI1C,EAAI,EAAGA,EAAI+F,EAAW/F,IAC7B,IAAK,IAAIkE,EAAIkC,EAAkBV,EAAmBxB,EAAI8B,EAAY9B,IAChE+B,EAAevB,KAAK,CAClBhG,EAAGsB,EACHrB,EAAGuF,EACH7E,MAAO,UACPoD,KAAMC,IAKZ,IAAK,IAAI1C,EAAI,EAAGA,EAAIqG,EAAiBrG,IACnC,IAAK,IAAIkE,EAAIkC,EAAiBlC,EAAIkC,EAAkBV,EAAmBxB,IACrE+B,EAAevB,KAAK,CAClBhG,EAAGsB,EACHrB,EAAGuF,EACH7E,MAAO,UACPoD,KAAMC,IAKZ,IAAK,IAAI1C,EAAIqG,EAAkBZ,EAAkBzF,EAAI+F,EAAW/F,IAC9D,IAAK,IAAIkE,EAAIkC,EAAiBlC,EAAIkC,EAAkBV,EAAmBxB,IACrE+B,EAAevB,KAAK,CAClBhG,EAAGsB,EACHrB,EAAGuF,EACH7E,MAAO,UACPoD,KAAMC,IAKZ,IAAM4D,EAAuBL,EAAeM,MAAK,SAAC/C,EAAGD,GACnD,OAAIC,EAAE9E,IAAM6E,EAAE7E,EACL8E,EAAE7E,EAAI4E,EAAE5E,EAEV6E,EAAE9E,EAAI6E,EAAE7E,KAGjB,MAAO,CAAE8H,GAAIC,KAAKC,MAAO1E,SAAUsE,EAAsB5D,UAASC,aAkE9CgE,CAJsF,EAElGlB,iBAFkG,EAEhFC,kBAE2DxC,EAAQ3B,EAAOC,GAGpG,OAFA0B,EAAO0D,SAEAd,E,oBC7NM,SAASe,EAAT,GAA2D,IAAtCC,EAAqC,EAArCA,UAAWC,EAA0B,EAA1BA,OAAQnI,EAAkB,EAAlBA,SAEnD,OACI,qBAAKC,UAAWC,IAAOkI,cAAehI,MAAO,CAAC,eAAgB8H,EAAW,YAAaC,GAAtF,SACI,qBAAKlI,UAAWC,IAAOmI,KAAvB,SACKrI,MCJF,SAASsI,IAEtB,IAKMC,EAAYjJ,iBAAO,GACnBkJ,EAAelJ,kBAAO,GARA,EAkBckB,mBARE,CAC1CoH,GAAI,EACJxE,SAAU,GACVU,QAAS,EACTC,UAAW,MAde,mBAkBrB0E,EAlBqB,KAkBNC,EAlBM,OAuBwBlI,mBAHD,IApBvB,mBAuBrBmI,EAvBqB,KAuBDC,EAvBC,OA0BsBpI,mBAAS,GA1B/B,mBA0BrBqI,EA1BqB,KA0BFC,EA1BE,OCRf,WAA0B,IAAD,EACAtI,mBAAS,CAACmC,MAAOoG,OAAOC,WAAYpG,OAAQmG,OAAOE,cADnD,mBAC7BC,EAD6B,KACjBC,EADiB,KAapC,OAVA5J,qBAAU,WACR,IAAM6J,EAAe,WACnBD,EAAc,CAACxG,MAAOoG,OAAOC,WAAYpG,OAAQmG,OAAOE,eAK1D,OAFAF,OAAOM,iBAAiB,SAAUD,GAE3B,kBAAML,OAAOO,oBAAoB,SAAUF,MACjD,IAEIF,EDuB4CK,GAAtCC,EA5Ba,EA4BpB7G,MAA4B8G,EA5BR,EA4BA7G,OA5BA,EA6BJpC,mBAAS,CAAEmC,MAAO,EAAGC,OAAQ,IA7BzB,mBA6BrByF,EA7BqB,KA6BfqB,EA7Be,KA+B5BnK,qBAAU,WACR,GAAIiK,EAAcC,EAAc,CAE9BC,EAAQ,CAAE/G,MA7BI,GA6BGC,OAAQc,KAAKC,MAAM8F,EAAeD,EA7BrC,UA8BT,CAELE,EAAQ,CAAE/G,MAAOe,KAAKC,MAAM6F,EAAcC,EAhC5B,IAgCoD7G,OAhCpD,QAkCf,CAAC4G,EAAaC,IAGjB,IAAME,EAAuB,SAACzC,GAC5BwB,EAAiBxB,IAGnB3H,qBAAU,WACJoJ,EAAmBxE,OAAS,IAAMqE,EAAahJ,UACjDmK,EAAqBhB,EAAmB,IACxCH,EAAahJ,SAAU,KAExB,CAACmJ,IAGJ,IAOMiB,EAAY,SAAC5G,IAPkB,SAACkE,GACpC,IAAM2C,EAAS,YAAOlB,GACtBkB,EAAU/D,KAAKoB,GACf0B,EAAsBiB,GAMtBC,CADoB9D,EAAqBhD,EAAOqF,EAAK1F,MAAO0F,EAAKzF,UAsB7DmH,EAA+B,SAAC/G,GACpC4G,EAAU5G,EAAMgH,SAIZC,EAAmB,SAAnBA,IACJ,GAAItB,EAAmBxE,OAAS,EAAG,CACjC,IAAM+F,GAAiBrB,EAAoB,GAAKF,EAAmBxE,OAC/DwE,EAAmBE,GAAmBjB,KAAOe,EAAmBuB,GAAetC,IACjFkB,EAAqBoB,GACrBP,EAAqBhB,EAAmBuB,MAExCpB,EAAqBoB,GACrBD,OAiBN,OAXA/K,GAAQ,WACFsJ,IACwB,IAAtBD,EAAU/I,QACZyK,IAGA1B,EAAU/I,QAAU+I,EAAU/I,QAAU,KAG3C,KAGD,sBAAKS,UAAWC,IAAOiK,aAAvB,UACE,qBAAKC,IAAI,WAAWC,OAAQN,EAA8B9J,UAAWC,IAAOoK,YAAaC,IAAI,SAC7F,qBAAKH,IAAI,WAAWC,OAAQN,EAA8B9J,UAAWC,IAAOoK,YAAaC,IAAI,SAC7F,qBAAKH,IAAI,WAAWC,OAAQN,EAA8B9J,UAAWC,IAAOoK,YAAaC,IAAI,SAC7F,qBAAKH,IAAI,YAAYC,OAAQN,EAA8B9J,UAAWC,IAAOoK,YAAaC,IAAI,SAC9F,cAACtC,EAAD,CAAYC,UAAWG,EAAK1F,MAAOwF,OAAQE,EAAKzF,OAAhD,SACE,cAACH,EAAD,CAAeC,YAAa+F,EAAe9G,UAvH/B,GAuHqDgB,MAAO0F,EAAK1F,MAAOC,OAAQyF,EAAKzF,WAEnG,uBAAO4H,KAAK,OAAO5C,GAAG,cAAc6C,KAAK,cAAcxK,UAAWC,IAAOwK,UAAWC,SAxDvD,SAACC,GAChC,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,SAACC,GACb,IAAMC,EAAM,IAAIC,MACVzF,EAAMuF,EAAEhB,OACVvE,IACFwF,EAAIb,IAAJ,UAAa3E,EAAI0F,SAEnBF,EAAIF,OAAS,WAAQnB,EAAUqB,KAEnC,IAAMxF,EAAMmF,EAAMZ,OAAOoB,MACrB3F,GACFoF,EAAOQ,cAAc5F,EAAI,UEzF/B,IAYe6F,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFhG,SAASiG,eAAe,SAM1BZ,M","file":"static/js/main.d27969ac.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"demoFullSize\":\"App_demoFullSize__Qo3zK\",\"hideImgTest\":\"App_hideImgTest__p4AEN\",\"inputTest\":\"App_inputTest__Drrbd\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cellWrapper\":\"SquareCell_cellWrapper__26luM\",\"cell\":\"SquareCell_cell__1xXeM\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gridContainer\":\"SquareGrid_gridContainer__1Ll0_\",\"grid\":\"SquareGrid_grid__2Kdlq\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cell\":\"Wave_cell__2PRUI\"};","import { useEffect, useRef } from 'react';\n\nexport default function useTick(func: () => void, time: number) {\n  const savedFunction = useRef(() => {});\n  useEffect(() => {\n    savedFunction.current = func;\n  })\n\n  useEffect(() => {\n    const interval = setInterval(() => { savedFunction.current(); }, time);\n    return () => clearInterval(interval);\n  }, [time]);\n\n  return null;\n}\n","export default interface WaveConfig {\n    nbPeriod: number,\n    intensity: number,\n    color: string,\n    phase: WavePhase,\n}\n\nexport enum WavePhase {\n    DISPLAYED,\n    WHITE_LINE,\n    WHITE_LINE_PREPARATION\n}\n","import React from 'react';\nimport styles from './SquareCell.module.css';\n\ninterface Props {\n    x: number;\n    y: number;\n    children: React.ReactNode;\n}\n\nexport default function SquareCell({x, y, children}: Props) {\n    return (\n        <div className={styles.cellWrapper} style={{\"--x\": x, \"--y\": y}}>\n            <div className={styles.cell}>\n                {children}\n            </div>\n        </div>\n      );\n}\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport styles from './Wave.module.css';\nimport WaveConfig, { WavePhase } from './type';\n\ninterface Props {\n    waveConfig: WaveConfig,\n}\n\nexport default function Wave({waveConfig}: Props) {\n    /** The currently displayed color */\n    const [displayedColor, setDisplayedColor] = useState(waveConfig.color);\n\n    /** The saved number of wave's period */\n    const nbPeriodSaved = useRef(waveConfig.nbPeriod);\n\n    const phase = useRef(WavePhase.DISPLAYED);\n\n    /** To compute the path by giving the number of period and its intensity */\n    const computePath = (nbPeriodForPath: number, intensityForPath: number) => {\n        let res = 'M 0 50';\n        for (let i = 1; i <= nbPeriodForPath; i++) {\n            const point = (100 / nbPeriodForPath) * i\n            const previousPoint = (100 / nbPeriodForPath) * (i - 1)\n            const halfway = ((point - previousPoint) / 2) + previousPoint;\n\n            const intensityValue = (intensityForPath / 100) * 170;\n            const low = 50 - intensityValue; // min -120\n            const hight = 50 + intensityValue; // max 220\n            res += ` C ${halfway} ${low} ${halfway} ${hight} ${point} 50`;\n        }\n        return res;\n    }\n\n    /** The svg path of the wave */\n    const [path, setPath] = useState(computePath(waveConfig.nbPeriod, waveConfig.intensity));\n\n    /** To be able to make a transition between the current wave and the new wave to display */\n    const goToWhiteLine = useCallback(() => {\n        setPath(computePath(nbPeriodSaved.current, 1));\n        setDisplayedColor('#424242');\n    }, []);\n\n    /** To display a new wave */\n    const goToNewPath = useCallback(() => {\n        setPath(computePath(waveConfig.nbPeriod, waveConfig.intensity));\n        setDisplayedColor(waveConfig.color);\n    }, [waveConfig.nbPeriod, waveConfig.intensity, waveConfig.color]);\n\n    const prepareNewPath = useCallback(() => {\n        setPath(computePath(waveConfig.nbPeriod, 1));\n        nbPeriodSaved.current = waveConfig.nbPeriod\n        setDisplayedColor('#424242');\n    }, [waveConfig.nbPeriod]);\n\n    useEffect(() => {\n        if (phase.current !== waveConfig.phase) {\n            phase.current = waveConfig.phase;\n            switch (phase.current) {\n                case WavePhase.WHITE_LINE:\n                    goToWhiteLine();\n                    break;\n                case WavePhase.DISPLAYED:\n                    goToNewPath();\n                    break;\n                default:\n                    prepareNewPath();\n                    break;\n                }\n        }\n    }, [waveConfig.phase, goToWhiteLine, goToNewPath, prepareNewPath])\n\n    return (\n        <div className={styles.cell}>\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox={`-1 -1 101 101`}>\n                <path style={{\"--path\": `'${path}'`, \"--color\": displayedColor}} strokeWidth=\"2\" fill=\"none\" vectorEffect=\"non-scaling-stroke\" strokeLinecap=\"round\"/>\n            </svg>\n        </div>\n      );\n}\n","import { MutableRefObject, useEffect, useRef, useState } from 'react';\nimport SquareCell from '../SquareCell/SquareCell';\nimport { ImageWavified } from '../type';\nimport useTick from '../useTick/useTick';\nimport { WavePhase } from '../Wave/type';\nimport Wave from '../Wave/Wave';\n\ninterface Props {\n    imageConfig: ImageWavified;\n    intensity: number;\n    width: number;\n    height: number;\n}\n\nexport default function WavifiedImage({imageConfig, intensity, width, height}: Props) {\n    const [progress, setProgress] = useState(-10);\n    const imagePhase: MutableRefObject<WavePhase[]> = useRef([]);\n\n    const [image, setImage] = useState(imageConfig);\n    const firstDisplay = useRef(0);\n\n    const biggestSide = width > height ? width : height;\n\n    useTick(() => {\n        if (progress <= 100 && firstDisplay.current > 2) {\n            imagePhase.current = image.listWave.map((elt, index) => {\n                const position = (elt.x / width * 100);\n                if (elt.y % 2 === 0) {\n                    if (position <= progress) {\n                        return WavePhase.DISPLAYED;\n                    } else if (position <= progress + 1) {\n                        return WavePhase.WHITE_LINE_PREPARATION;\n                    } else if (position <= progress + 10) {\n                        return WavePhase.WHITE_LINE;\n                    }\n                } else {\n                    if (position >= 100 - progress) {\n                        return WavePhase.DISPLAYED;\n                    } else if (position >= 100 - (progress + 1)) {\n                        return WavePhase.WHITE_LINE_PREPARATION;\n                    } else if (position >= 100 - (progress + 10)) {\n                        return WavePhase.WHITE_LINE;\n                    }\n                }\n\n                return imagePhase.current[index];\n            });\n            setProgress(progress + Math.round(biggestSide / width));\n        }\n    }, 50);\n\n    useEffect(() => {\n        setImage(prevImage => (prevImage));\n    }, [progress]);\n\n    useEffect(() => {\n        setProgress(-10);\n        setImage(imageConfig);\n        if (firstDisplay.current < 3) {\n            firstDisplay.current = firstDisplay.current + 1;\n            imagePhase.current = imageConfig.listWave.map(() => WavePhase.DISPLAYED);\n        }\n    }, [imageConfig]);\n\n    return <>{\n        image.listWave.map((waveConfig, index) => {\n            const nbPeriod = Math.round((waveConfig.grey - imageConfig.darkest) / (imageConfig.brightest - imageConfig.darkest) * 4);\n\n            return <SquareCell x={waveConfig.x} y={waveConfig.y} key={'square'+index}>\n                <Wave waveConfig={{\n                    nbPeriod: nbPeriod === 0 ? 1 : nbPeriod,\n                    intensity: nbPeriod === 0 ? 0 : intensity,\n                    color: waveConfig.color,\n                    phase: imagePhase.current[index]\n                }} key={'wave'+index}/>\n            </SquareCell>\n        })\n    }</>;\n}","import { Box, Color, ImageWavified, WaveConfig } from \"../type\";\n\n/** To get a string of at least given size by puting zeros at the left */\nexport function fillStringWithZero(originalText: string, nbCharInOutput: number): string {\n  let res = originalText;\n  while (res.length < nbCharInOutput) {\n    res = `0${res}`;\n  }\n  return res;\n};\n\n/** To get a string usable as a css color */\nexport function colorObjectToHexa(colorObject: Color): string {\n  return `#${fillStringWithZero(colorObject.r, 2)}${fillStringWithZero(colorObject.g, 2)}${fillStringWithZero(colorObject.b, 2)}${fillStringWithZero(colorObject.a, 2)}`\n}\n\n/** To get the avergage color and the greyscale of a pixel array */\nexport function computeAverageColorAndGreyLvlFromPixelsArray(pixelsToCompute: Uint8ClampedArray[]): {color: string, grey: number} {\n  const pixelSommeByColorComposant = {r: 0, g: 0, b: 0, a: 0};\n  pixelsToCompute.forEach(pixel => {\n    pixelSommeByColorComposant.r += pixel[0];\n    pixelSommeByColorComposant.g += pixel[1];\n    pixelSommeByColorComposant.b += pixel[2];\n    pixelSommeByColorComposant.a += pixel[3];\n  });\n  const averageColor = {\n    r: Math.round(pixelSommeByColorComposant.r / pixelsToCompute.length),\n    g: Math.round(pixelSommeByColorComposant.g / pixelsToCompute.length),\n    b: Math.round(pixelSommeByColorComposant.b / pixelsToCompute.length),\n    a: Math.round(pixelSommeByColorComposant.a / pixelsToCompute.length),\n  }\n  const avergageColorInHexa = {\n    r: averageColor.r.toString(16),\n    g: averageColor.g.toString(16),\n    b: averageColor.b.toString(16),\n    a: averageColor.a.toString(16),\n  }\n\n  return {\n    color: colorObjectToHexa(avergageColorInHexa),\n    grey: (averageColor.r + averageColor.g + averageColor.b) / 3,\n  };\n}\n\n/** Reduce a two dimensional pixel array from a given canvas to a single dimension array */\nexport function partImageToArray(boundaries: Box, canvas: HTMLCanvasElement): Uint8ClampedArray[] {\n  const pixelsToCompute = [];\n  for (let i = boundaries.left; i < boundaries.right; i++) {\n    for (let j = boundaries.top; j < boundaries.bottom; j++) {\n      const tmp = canvas.getContext('2d')\n      if (tmp) {\n        const originalPixel = tmp.getImageData(i, j, 1, 1).data;\n        pixelsToCompute.push(originalPixel);\n      }\n    }\n  }\n\n  return pixelsToCompute;\n}\n\n/** To get the avergage color and the greyscale of a given canvas part */\nexport function computeColorAndGreyLvlForPartImage(boundaries: Box, canvas: HTMLCanvasElement): {color: string, grey: number} {\n  const pixelsToCompute = partImageToArray(boundaries, canvas);\n  return computeAverageColorAndGreyLvlFromPixelsArray(pixelsToCompute);\n}\n\n/** To get the boundary coordinates */\nexport function computeSubImageBoundaries(top: number, left: number, height: number, width: number): Box {\n  return {\n    left: Math.round(left),\n    right: Math.round(left + width - 1),\n    top: Math.round(top),\n    bottom: Math.round(top + height - 1),\n  }\n}\n\n/** To get a the config of all waves generated by the given canvas */\nexport function getListWaveConfigFromCanvas(drawedImageWidth: number, drawedImageHeight: number, canvas: HTMLCanvasElement, gridWidth: number, gridHeight: number): ImageWavified {\n  const listWaveConfig: WaveConfig[] = [];\n  \n  const canvasSubPartWidth = canvas.width / drawedImageWidth;\n  const canvasSubPartHeight = canvas.height / drawedImageHeight;\n  \n  let darkest = 255;\n  let brightest = 0;\n\n  const borderTopHeight = Math.trunc((gridHeight - drawedImageHeight) / 2);\n  const borderLeftWidth = Math.trunc((gridWidth - drawedImageWidth) / 2);\n\n  for(let i = 0; i < drawedImageWidth; i++) {\n    for (let j = 0; j < drawedImageHeight; j++) {\n      const boundaries = computeSubImageBoundaries(canvasSubPartHeight * j, canvasSubPartWidth * i, canvasSubPartHeight, canvasSubPartWidth)\n      const {color, grey} = computeColorAndGreyLvlForPartImage(boundaries, canvas);\n\n      listWaveConfig.push({\n        x: i + borderLeftWidth,\n        y: j + borderTopHeight,\n        color: color,\n        grey: grey,\n      });\n\n      if (darkest > grey) {\n        darkest = grey;\n      }\n      if (brightest < grey) {\n        brightest = grey;\n      }\n    }\n  }\n\n  for (let i = 0; i < gridWidth; i++) {\n    for (let j = 0; j < borderTopHeight; j++) {\n      listWaveConfig.push({\n        x: i,\n        y: j,\n        color: '#424242',\n        grey: darkest,\n      });\n    }\n  }\n  \n  for (let i = 0; i < gridWidth; i++) {\n    for (let j = borderTopHeight + drawedImageHeight; j < gridHeight; j++) {\n      listWaveConfig.push({\n        x: i,\n        y: j,\n        color: '#424242',\n        grey: darkest,\n      });\n    }\n  }\n  \n  for (let i = 0; i < borderLeftWidth; i++) {\n    for (let j = borderTopHeight; j < borderTopHeight + drawedImageHeight; j++) {\n      listWaveConfig.push({\n        x: i,\n        y: j,\n        color: '#424242',\n        grey: darkest,\n      });\n    }\n  }\n  \n  for (let i = borderLeftWidth + drawedImageWidth; i < gridWidth; i++) {\n    for (let j = borderTopHeight; j < borderTopHeight + drawedImageHeight; j++) {\n      listWaveConfig.push({\n        x: i,\n        y: j,\n        color: '#424242',\n        grey: darkest,\n      });\n    }\n  }\n\n  const listWaveConfigSorted = listWaveConfig.sort((a, b) => {\n    if (a.x === b.x) {\n      return a.y - b.y;\n    }\n    return a.x - b.x;\n  });\n\n  return { id: Date.now(), listWave: listWaveConfigSorted, darkest, brightest };\n}\n\n/** Create an hidden canvas and display the given image */\nexport function createHiddenCanvasFromImage(image: HTMLImageElement): HTMLCanvasElement {\n  const canvas = document.createElement('canvas');\n\n  let canvasComputedWidth = image.width;\n  let canvasComputedHeight = image.height;\n  const maxSize = 200;\n\n  if (canvasComputedWidth > maxSize || canvasComputedHeight > maxSize) {\n    const ratio = canvasComputedWidth / canvasComputedHeight;\n    if (canvasComputedWidth > canvasComputedHeight) {\n      canvasComputedWidth = maxSize;\n      canvasComputedHeight = maxSize / ratio;\n    } else {\n      canvasComputedWidth = maxSize * ratio;\n      canvasComputedHeight = maxSize;\n    }\n  }\n\n  canvas.width = canvasComputedWidth;\n  canvas.height = canvasComputedHeight;\n\n  const tmp = canvas.getContext('2d');\n  if (tmp) {\n    tmp.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n  }\n\n  return canvas;\n}\n\n/** To get the grid size based on the image proportion and the max grid size */\nexport function computeDrawedGridSizeFromImage({width: originalImageWidth, height: originalImageHeight}: {width: number, height: number}, outputImageWidth: number, outputImageHeight: number): { drawedImageWidth: number, drawedImageHeight: number } {\n  let drawedImageWidth = 0;\n  let drawedImageHeight = 0;\n\n  if (originalImageWidth > originalImageHeight) {\n    const coef = originalImageWidth / outputImageWidth;\n    drawedImageWidth = outputImageWidth;\n    drawedImageHeight = Math.trunc(originalImageHeight / coef);\n  \n    if (drawedImageHeight > outputImageHeight) {\n      drawedImageWidth = Math.trunc(originalImageWidth / coef);\n      drawedImageHeight = outputImageHeight;\n    }\n  } else {\n    const coef = originalImageHeight / outputImageHeight;\n    drawedImageWidth = Math.trunc(originalImageWidth / coef);\n    drawedImageHeight = outputImageHeight;\n  \n    if (drawedImageWidth > outputImageWidth) {\n      drawedImageWidth = outputImageWidth;\n      drawedImageHeight = Math.trunc(originalImageHeight / coef);\n    }\n  }\n  \n  return { drawedImageWidth, drawedImageHeight };\n}\n\n/** To get a list of wave component to display in grid from a given image */\nexport function getListWaveFromImage(image: HTMLImageElement, width: number, height: number): ImageWavified {\n  const canvas = createHiddenCanvasFromImage(image);\n  const { drawedImageWidth, drawedImageHeight } = computeDrawedGridSizeFromImage(image, width, height);\n\n  const imgWavified = getListWaveConfigFromCanvas(drawedImageWidth, drawedImageHeight, canvas, width, height);\n  canvas.remove();\n\n  return imgWavified;\n}","import React from 'react';\nimport styles from './SquareGrid.module.css';\n\ninterface Props {\n    nbColumns: number;\n    nbRows: number;\n    children: React.ReactNode;\n}\n\nexport default function SquareGrid({nbColumns, nbRows, children}: Props) {\n    // TODO Reuse component from nerv-ui project\n    return (\n        <div className={styles.gridContainer} style={{\"--nb-columns\": nbColumns, \"--nb-rows\": nbRows}}>\n            <div className={styles.grid}>\n                {children}\n            </div>\n        </div>\n      );\n}\n","import './App.css';\nimport styles from './App.module.css';\nimport { ChangeEvent, SyntheticEvent, useEffect, useRef, useState } from 'react';\nimport useTick from './useTick/useTick';\nimport WavifiedImage from './WavifiedImage/WavifiedImage';\nimport { ImageWavified } from './type';\nimport { getListWaveFromImage } from './WavifiedImage/WavifyUtils';\nimport useScreenSize from './useScreenSize/useScreenSize';\nimport SquareGrid from './SquareGrid/SquareGrid';\n\nexport default function App() {\n  /** The vertical size of the waves */\n  const intensity = 50;\n\n  /** The number of waves for the longest side of the image */\n  const maxLength = 45;\n\n  const delayTick = useRef(1);\n  const tickCanStart = useRef(false);\n\n  const defaultImageWavified: ImageWavified = {\n    id: 0,\n    listWave: [],\n    darkest: 0,\n    brightest: 100\n  };\n\n  /** The list of wavified image to display */\n  const [imageWavified, setImageWavified] = useState(defaultImageWavified);\n\n  const defaultListImagesWavified: ImageWavified[] = []\n\n  /** The list of wavified image available to display */\n  const [listImagesWavified, setListImagesWavified] = useState(defaultListImagesWavified);\n\n  /** The index of the current image displayed from images */\n  const [currentImageIndex, setCurrentImageIndex] = useState(0);\n  \n  const { width: widthScreen, height: heightScreen } = useScreenSize();\n  const [grid, setGrid] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    if (widthScreen > heightScreen) {\n      const width = maxLength;\n      setGrid({ width, height: Math.round(heightScreen / widthScreen * width) });\n    } else {\n      const height = maxLength;\n      setGrid({ width: Math.round(widthScreen / heightScreen * height), height });\n    }\n  }, [widthScreen, heightScreen]);\n\n  /** To display the given wavified image */\n  const displayWavifiedImage = (imgWavified: ImageWavified) => {\n    setImageWavified(imgWavified);\n  }\n\n  useEffect(() => {\n    if (listImagesWavified.length > 0 && !tickCanStart.current) {\n      displayWavifiedImage(listImagesWavified[0]);\n      tickCanStart.current = true;\n    }\n  }, [listImagesWavified])\n\n  /** To add the given wavified image to the images list */\n  const addWavifiedImageToImagesList = (imgWavified: ImageWavified) => {\n    const newImages = [...listImagesWavified];\n    newImages.push(imgWavified);\n    setListImagesWavified(newImages);\n  }\n\n  /** To handle a new image loaded */\n  const imgLoaded = (image: HTMLImageElement) => {\n    const imgWavified = getListWaveFromImage(image, grid.width, grid.height);\n    addWavifiedImageToImagesList(imgWavified);\n  }\n\n  /** To handle an image from an input file */\n  const handleImageLoadFromInput = (event: ChangeEvent<HTMLInputElement>) => {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n        const img = new Image();\n        const tmp = e.target;\n        if (tmp) {\n          img.src = `${tmp.result}`;\n        }\n        img.onload = () => { imgLoaded(img) };\n    }\n    const tmp = event.target.files;\n    if (tmp) {\n      reader.readAsDataURL(tmp[0]);\n    }\n  }\n\n  /** To handle an image from an img html balise */\n  const handleImageLoadFromImgBalise = (image: SyntheticEvent<HTMLImageElement, Event>) => {\n    imgLoaded(image.target as HTMLImageElement);\n  }\n\n  /** To display the next image in the images list */\n  const displayNextImage = () => {\n    if (listImagesWavified.length > 1) {\n      const newImageIndex = (currentImageIndex + 1) % listImagesWavified.length;\n      if (listImagesWavified[currentImageIndex].id !== listImagesWavified[newImageIndex].id) {\n        setCurrentImageIndex(newImageIndex);\n        displayWavifiedImage(listImagesWavified[newImageIndex]);\n      } else {\n        setCurrentImageIndex(newImageIndex);\n        displayNextImage();\n      }\n    }\n  }\n\n  /** To display a new image every 20 seconds */\n  useTick(() => {\n    if (tickCanStart) {\n      if (delayTick.current === 0) {\n        displayNextImage();\n      }\n      else {\n        delayTick.current = delayTick.current - 1;\n      }\n    }\n  }, 20000);\n\n  return (\n    <div className={styles.demoFullSize}>\n      <img src=\"nuit.jpg\" onLoad={handleImageLoadFromImgBalise} className={styles.hideImgTest} alt=\"test\"></img>\n      <img src=\"link.jpg\" onLoad={handleImageLoadFromImgBalise} className={styles.hideImgTest} alt=\"test\"></img>\n      <img src=\"mona.jpg\" onLoad={handleImageLoadFromImgBalise} className={styles.hideImgTest} alt=\"test\"></img>\n      <img src=\"mario.jpg\" onLoad={handleImageLoadFromImgBalise} className={styles.hideImgTest} alt=\"test\"></img>\n      <SquareGrid nbColumns={grid.width} nbRows={grid.height}>\n        <WavifiedImage imageConfig={imageWavified} intensity={intensity} width={grid.width} height={grid.height}></WavifiedImage>\n      </SquareGrid>\n      <input type=\"file\" id=\"imageLoader\" name=\"imageLoader\" className={styles.inputTest} onChange={handleImageLoadFromInput}/>\n    </div>\n  );\n}","import { useState, useEffect } from 'react';\n\nexport default function useScreenSize() {\n    const [screenSize, setScreenSize] = useState({width: window.innerWidth, height: window.innerHeight});\n  \n    useEffect(() => {\n      const handleResize = () => {\n        setScreenSize({width: window.innerWidth, height: window.innerHeight});\n      }\n  \n      window.addEventListener('resize', handleResize);\n\n      return () => window.removeEventListener('resize', handleResize);\n    }, []);\n  \n    return screenSize;\n  }","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}